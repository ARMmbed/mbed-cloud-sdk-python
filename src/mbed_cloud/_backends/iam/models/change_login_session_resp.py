# coding: utf-8

"""
    Account Management API

    API for managing accounts, users, creating API keys, uploading trusted certificates

    OpenAPI spec version: v3
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from pprint import pformat
from six import iteritems
import re


class ChangeLoginSessionResp(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    """


    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'status': 'str',
        'user_id': 'str',
        'account_id': 'str',
        'roles': 'list[str]',
        'token': 'str',
        'parent_account_id': 'str',
        'mfa_status': 'str'
    }

    attribute_map = {
        'status': 'status',
        'user_id': 'user_id',
        'account_id': 'account_id',
        'roles': 'roles',
        'token': 'token',
        'parent_account_id': 'parent_account_id',
        'mfa_status': 'mfa_status'
    }

    def __init__(self, status=None, user_id=None, account_id=None, roles=None, token=None, parent_account_id=None, mfa_status=None):
        """
        ChangeLoginSessionResp - a model defined in Swagger
        """

        self._status = status
        self._user_id = user_id
        self._account_id = account_id
        self._roles = roles
        self._token = token
        self._parent_account_id = parent_account_id
        self._mfa_status = mfa_status
        self.discriminator = None

    @property
    def status(self):
        """
        Gets the status of this ChangeLoginSessionResp.
        The status of the logged in user. 'Reset' means that the password must be changed immediately.

        :return: The status of this ChangeLoginSessionResp.
        :rtype: str
        """
        return self._status

    @status.setter
    def status(self, status):
        """
        Sets the status of this ChangeLoginSessionResp.
        The status of the logged in user. 'Reset' means that the password must be changed immediately.

        :param status: The status of this ChangeLoginSessionResp.
        :type: str
        """
        if status is None:
            raise ValueError("Invalid value for `status`, must not be `None`")
        allowed_values = ["Active", "Reset", "Inactive"]
        if status not in allowed_values:
            raise ValueError(
                "Invalid value for `status` ({0}), must be one of {1}"
                .format(status, allowed_values)
            )

        self._status = status

    @property
    def user_id(self):
        """
        Gets the user_id of this ChangeLoginSessionResp.
        User ID.

        :return: The user_id of this ChangeLoginSessionResp.
        :rtype: str
        """
        return self._user_id

    @user_id.setter
    def user_id(self, user_id):
        """
        Sets the user_id of this ChangeLoginSessionResp.
        User ID.

        :param user_id: The user_id of this ChangeLoginSessionResp.
        :type: str
        """
        if user_id is None:
            raise ValueError("Invalid value for `user_id`, must not be `None`")

        self._user_id = user_id

    @property
    def account_id(self):
        """
        Gets the account_id of this ChangeLoginSessionResp.
        The UUID of the account where the user login session is changed to.

        :return: The account_id of this ChangeLoginSessionResp.
        :rtype: str
        """
        return self._account_id

    @account_id.setter
    def account_id(self, account_id):
        """
        Sets the account_id of this ChangeLoginSessionResp.
        The UUID of the account where the user login session is changed to.

        :param account_id: The account_id of this ChangeLoginSessionResp.
        :type: str
        """
        if account_id is None:
            raise ValueError("Invalid value for `account_id`, must not be `None`")

        self._account_id = account_id

    @property
    def roles(self):
        """
        Gets the roles of this ChangeLoginSessionResp.
        The roles of the logged in user.

        :return: The roles of this ChangeLoginSessionResp.
        :rtype: list[str]
        """
        return self._roles

    @roles.setter
    def roles(self, roles):
        """
        Sets the roles of this ChangeLoginSessionResp.
        The roles of the logged in user.

        :param roles: The roles of this ChangeLoginSessionResp.
        :type: list[str]
        """
        if roles is None:
            raise ValueError("Invalid value for `roles`, must not be `None`")

        self._roles = roles

    @property
    def token(self):
        """
        Gets the token of this ChangeLoginSessionResp.
        Reference token.

        :return: The token of this ChangeLoginSessionResp.
        :rtype: str
        """
        return self._token

    @token.setter
    def token(self, token):
        """
        Sets the token of this ChangeLoginSessionResp.
        Reference token.

        :param token: The token of this ChangeLoginSessionResp.
        :type: str
        """
        if token is None:
            raise ValueError("Invalid value for `token`, must not be `None`")

        self._token = token

    @property
    def parent_account_id(self):
        """
        Gets the parent_account_id of this ChangeLoginSessionResp.
        The UUID of the parent account.

        :return: The parent_account_id of this ChangeLoginSessionResp.
        :rtype: str
        """
        return self._parent_account_id

    @parent_account_id.setter
    def parent_account_id(self, parent_account_id):
        """
        Sets the parent_account_id of this ChangeLoginSessionResp.
        The UUID of the parent account.

        :param parent_account_id: The parent_account_id of this ChangeLoginSessionResp.
        :type: str
        """
        if parent_account_id is None:
            raise ValueError("Invalid value for `parent_account_id`, must not be `None`")

        self._parent_account_id = parent_account_id

    @property
    def mfa_status(self):
        """
        Gets the mfa_status of this ChangeLoginSessionResp.
        The enforcement status of setting up the multi-factor authentication. 'Enabled' means that the MFA has been enabled despite the enforcement. 'Enforced' means that setting up the MFA is required after login. 'Optional' means that the MFA is not required.

        :return: The mfa_status of this ChangeLoginSessionResp.
        :rtype: str
        """
        return self._mfa_status

    @mfa_status.setter
    def mfa_status(self, mfa_status):
        """
        Sets the mfa_status of this ChangeLoginSessionResp.
        The enforcement status of setting up the multi-factor authentication. 'Enabled' means that the MFA has been enabled despite the enforcement. 'Enforced' means that setting up the MFA is required after login. 'Optional' means that the MFA is not required.

        :param mfa_status: The mfa_status of this ChangeLoginSessionResp.
        :type: str
        """
        if mfa_status is None:
            raise ValueError("Invalid value for `mfa_status`, must not be `None`")
        allowed_values = ["enabled", "enforced", "optional"]
        if mfa_status not in allowed_values:
            raise ValueError(
                "Invalid value for `mfa_status` ({0}), must be one of {1}"
                .format(mfa_status, allowed_values)
            )

        self._mfa_status = mfa_status

    def to_dict(self):
        """
        Returns the model properties as a dict
        """
        result = {}

        for attr, _ in iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """
        Returns the string representation of the model
        """
        return pformat(self.to_dict())

    def __repr__(self):
        """
        For `print` and `pprint`
        """
        return self.to_str()

    def __eq__(self, other):
        """
        Returns true if both objects are equal
        """
        if not isinstance(other, ChangeLoginSessionResp):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """
        Returns true if both objects are not equal
        """
        return not self == other
